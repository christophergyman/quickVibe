package auth

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestCredentialFilePath(t *testing.T) {
	tests := []struct {
		name        string
		projectPath string
		expected    string
	}{
		{
			name:        "simple path",
			projectPath: "/home/user/project",
			expected:    "/home/user/project/" + CredFileName,
		},
		{
			name:        "with trailing slash",
			projectPath: "/home/user/project/",
			expected:    "/home/user/project/" + CredFileName,
		},
		{
			name:        "relative path",
			projectPath: "project",
			expected:    "project/" + CredFileName,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := CredentialFilePath(tt.projectPath)
			// Use filepath.Clean to normalize for comparison
			if filepath.Clean(result) != filepath.Clean(tt.expected) {
				t.Errorf("CredentialFilePath(%q) = %q, want %q", tt.projectPath, result, tt.expected)
			}
		})
	}
}

func TestCredFileName(t *testing.T) {
	// Verify the constant value
	if CredFileName != ".claude-quick-auth" {
		t.Errorf("CredFileName = %q, want %q", CredFileName, ".claude-quick-auth")
	}
}

func TestWriteCredentialFile_Empty(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "test-cred-*")
	if err != nil {
		t.Fatalf("failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Empty credentials should not create a file
	err = WriteCredentialFile(tmpDir, map[string]string{})
	if err != nil {
		t.Errorf("WriteCredentialFile() with empty creds returned error: %v", err)
	}

	filePath := filepath.Join(tmpDir, CredFileName)
	if _, err := os.Stat(filePath); !os.IsNotExist(err) {
		t.Error("WriteCredentialFile() with empty creds created a file, but shouldn't")
	}
}

func TestWriteCredentialFile_SingleCredential(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "test-cred-*")
	if err != nil {
		t.Fatalf("failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	creds := map[string]string{
		"API_KEY": "secret-value-123",
	}

	err = WriteCredentialFile(tmpDir, creds)
	if err != nil {
		t.Fatalf("WriteCredentialFile() returned error: %v", err)
	}

	filePath := filepath.Join(tmpDir, CredFileName)
	content, err := os.ReadFile(filePath)
	if err != nil {
		t.Fatalf("failed to read credential file: %v", err)
	}

	contentStr := string(content)

	// Check header comments
	if !strings.Contains(contentStr, "# Generated by claude-quick") {
		t.Error("File should contain header comment")
	}

	// Check credential export
	if !strings.Contains(contentStr, "export API_KEY='secret-value-123'") {
		t.Errorf("File content = %q, should contain export statement", contentStr)
	}
}

func TestWriteCredentialFile_MultipleCredentials(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "test-cred-*")
	if err != nil {
		t.Fatalf("failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	creds := map[string]string{
		"API_KEY":      "secret1",
		"GITHUB_TOKEN": "ghp_secret2",
	}

	err = WriteCredentialFile(tmpDir, creds)
	if err != nil {
		t.Fatalf("WriteCredentialFile() returned error: %v", err)
	}

	filePath := filepath.Join(tmpDir, CredFileName)
	content, err := os.ReadFile(filePath)
	if err != nil {
		t.Fatalf("failed to read credential file: %v", err)
	}

	contentStr := string(content)

	// Check both credentials are present
	if !strings.Contains(contentStr, "export API_KEY='secret1'") {
		t.Error("File should contain API_KEY export")
	}
	if !strings.Contains(contentStr, "export GITHUB_TOKEN='ghp_secret2'") {
		t.Error("File should contain GITHUB_TOKEN export")
	}
}

func TestWriteCredentialFile_QuoteEscaping(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "test-cred-*")
	if err != nil {
		t.Fatalf("failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	tests := []struct {
		name     string
		value    string
		expected string
	}{
		{
			name:     "no quotes",
			value:    "simple-value",
			expected: "export TEST='simple-value'",
		},
		{
			name:     "single quote in middle",
			value:    "val'ue",
			expected: "export TEST='val'\"'\"'ue'",
		},
		{
			name:     "multiple single quotes",
			value:    "it's a test's value",
			expected: "export TEST='it'\"'\"'s a test'\"'\"'s value'",
		},
		{
			name:     "single quote at start",
			value:    "'start",
			expected: "export TEST=''\"'\"'start'",
		},
		{
			name:     "single quote at end",
			value:    "end'",
			expected: "export TEST='end'\"'\"''",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Clean up from previous test
			os.Remove(filepath.Join(tmpDir, CredFileName))

			creds := map[string]string{"TEST": tt.value}
			err := WriteCredentialFile(tmpDir, creds)
			if err != nil {
				t.Fatalf("WriteCredentialFile() returned error: %v", err)
			}

			filePath := filepath.Join(tmpDir, CredFileName)
			content, err := os.ReadFile(filePath)
			if err != nil {
				t.Fatalf("failed to read credential file: %v", err)
			}

			if !strings.Contains(string(content), tt.expected) {
				t.Errorf("File content = %q, should contain %q", string(content), tt.expected)
			}
		})
	}
}

func TestWriteCredentialFile_Permissions(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "test-cred-*")
	if err != nil {
		t.Fatalf("failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	creds := map[string]string{"TEST": "value"}
	err = WriteCredentialFile(tmpDir, creds)
	if err != nil {
		t.Fatalf("WriteCredentialFile() returned error: %v", err)
	}

	filePath := filepath.Join(tmpDir, CredFileName)
	info, err := os.Stat(filePath)
	if err != nil {
		t.Fatalf("failed to stat credential file: %v", err)
	}

	// Check permissions are 0600 (owner read/write only)
	mode := info.Mode().Perm()
	if mode != 0600 {
		t.Errorf("File permissions = %o, want %o", mode, 0600)
	}
}

func TestCleanupCredentialFile_Exists(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "test-cred-*")
	if err != nil {
		t.Fatalf("failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create the file first
	filePath := filepath.Join(tmpDir, CredFileName)
	if err := os.WriteFile(filePath, []byte("test"), 0600); err != nil {
		t.Fatalf("failed to create test file: %v", err)
	}

	// Cleanup should remove it
	err = CleanupCredentialFile(tmpDir)
	if err != nil {
		t.Errorf("CleanupCredentialFile() returned error: %v", err)
	}

	// Verify file is gone
	if _, err := os.Stat(filePath); !os.IsNotExist(err) {
		t.Error("CleanupCredentialFile() did not remove the file")
	}
}

func TestCleanupCredentialFile_NotExists(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "test-cred-*")
	if err != nil {
		t.Fatalf("failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// File doesn't exist - should not return error
	err = CleanupCredentialFile(tmpDir)
	if err != nil {
		t.Errorf("CleanupCredentialFile() for non-existent file returned error: %v", err)
	}
}

func TestWriteCredentialFile_NonexistentDir(t *testing.T) {
	// Try to write to a non-existent directory
	err := WriteCredentialFile("/nonexistent/path/that/does/not/exist", map[string]string{"TEST": "value"})
	if err == nil {
		t.Error("WriteCredentialFile() should return error for non-existent directory")
	}
}
